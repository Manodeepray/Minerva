
from langchain.tools import tool  
from bs4 import BeautifulSoup
from PIL import Image
import uuid
from transformers import AutoProcessor, LlavaOnevisionForConditionalGeneration
import torch , torchvision
from pprint import pprint
try:
    import Brain
except:
    from . import Brain

import re
import ast



def parse_form_fields(html):
    soup = BeautifulSoup(html, "html.parser")
    inputs = soup.find_all(['input', 'textarea'])
    field_names = [tag.get("name") for tag in inputs if tag.get("name")]
    return field_names
    

# use this to the the field values for prompt


async def fill_form_fields(page, values: dict):
    """
    Fill out and submit a form using parsed field names and user-provided values.
    Args:
        page: Pyppeteer page object
        values: Dict of field names and their values
    """
    for field_name, field_value in values.items():
        # if field_name != "email":    
        #     field_value = "<script>alert('XSS')</script> "


        selector = f'input[name="{field_name}"], textarea[name="{field_name}"], select[name="{field_name}"]'
        print(f"Filling: {selector} -> {field_value}")
        try:
            await page.waitForSelector(selector, timeout=2000)

            # Clear the input value using evaluate safely
            await page.evaluate(
                """(selector) => {
                    const el = document.querySelector(selector);
                    if (el) el.value = "";
                }""",
                selector
            )

            # Handle <select> separately if needed
            tag_name = await page.evaluate(
                """(selector) => {
                    const el = document.querySelector(selector);
                    return el ? el.tagName.toLowerCase() : null;
                }""",
                selector
            )

            if tag_name == "select":
                await page.select(selector, field_value)
            else:
                await page.type(selector, field_value)

        except Exception as e:
            print(f"⚠️ Failed to fill {field_name}: {e}")

    # Try to click the submit button
    try:
        submit_selectors = [
            'form button[type="submit"]',
            'form input[type="submit"]',
            'button[type="submit"]',
            'input[type="submit"]'
        ]
        for submit_selector in submit_selectors:
            try:
                await page.waitForSelector(submit_selector, timeout=1000)
                await page.click(submit_selector)
                await page.waitForNavigation(timeout=5000)
                return "✅ Form submitted."
            except:
                continue
        return "⚠️ No submit button found."
    except Exception as e:
        return f"⚠️ Failed to submit form: {e}"




@tool

async def XSS_injection_tool(state: dict, form_html: str, values: dict = None):
    """
    Fills out a form with an XSS payload to all non-email fields and submits it.
    Args:
        state: LangGraph agent state with a Puppeteer page
        form_html: HTML string of the form
        values: Optional dict to override the payloads
        
        vlaues format  = {  
                            name:abc,
                            email:xyv@mail.com ,
                            notes: dummy note
                            
                        }
    """
    # fields = parse_form_fields(form_html)
    fields = values
    filtered_values = {k: v for k, v in values.items() if k in fields}
    print(f"filtered_values : {filtered_values}")
    result = await fill_form_fields(state["page"], filtered_values)
    state["last_action"] = result
    return state


def get_json_from_response(response):
    match = re.search(r"(\{.*?\})", response, re.DOTALL)
    if match:
        dict_string = match.group(1)
        print("Raw match:", dict_string)

        # Clean the string from unwanted escape characters
        cleaned_string = dict_string.encode("utf-8").decode("unicode_escape")
        cleaned_string = cleaned_string.replace('\n', '').replace('\r', '').replace('\\', '').replace("\"" , "")

        print("Cleaned string:", cleaned_string)

        try:
            data = ast.literal_eval(cleaned_string)
            print("Extracted dictionary:", data)
            return data

        except Exception as e:
            print(f"❌ Error parsing cleaned dict: {e}")
    else:
        print("⚠️ No dictionary found in the string.")

    return None

















class XSSAnalyzer:
    def __init__(self):
        
        self.model_id = "llava-hf/llava-onevision-qwen2-0.5b-ov-hf"
        self.model = LlavaOnevisionForConditionalGeneration.from_pretrained(
            self.model_id,
            torch_dtype=torch.float16 if torch.cuda.is_available() else torch.float32,
            low_cpu_mem_usage=True,
            device_map="auto",
        )
        self.processor = AutoProcessor.from_pretrained(self.model_id)
        self.llm = Brain.WorkflowExtractor()


    def analyze_xss_image(self , image_path: str, question: str = "What text do you see in the picture ?"):
        """Uses the LLaVA vision-language model to analyze the screenshot."""
        image = Image.open(image_path).convert("RGB")

        # Chat template for multimodal input
        conversation = [
            {
                "role": "user",
                "content": [
                    {"type": "text", "text": question},
                    {"type": "image"}
                ]
            }
        ]

        prompt = self.processor.apply_chat_template(conversation, add_generation_prompt=True)
        inputs = self.processor(text=prompt, images=image, return_tensors="pt").to(self.model.device)

        output = self.model.generate(**inputs, max_new_tokens=100)
        decoded = self.processor.batch_decode(output, skip_special_tokens=True)[0]
        print(decoded)
        return decoded
    # print(analyze_xss_image("xss.png"))

    def check_with_llm(self , caption):
        print(caption)
        json_xss = """{'xss_triggered':True or False}"""


        json_xss_false = {'xss_triggered':False}

        xss_verification_prompt = f"""
            you are an smart tool that takes the visual caption of a web page after visiting a potentially XSS-injected URL:

            your job is to:
            1. check if the xss payload worked , payload = '<script>  document.body.innerHTML = '<h1 style="color:red">XSS WORKED</h1>';</script>'

            2. if payload worked successfully the ouput the  json 
            for example if caption : 
            What text do you see in the picture ?assistant
            The text in the picture reads "XSS WORKED". it worked
            3.if in the caption there is any mention of xss in red , or xss then injection worked  , otherwise it did not work 

            INSTRUCTION
            THINK  THEN RETURN THE DICTIONARY with value True if it workd and False if it did not work


            CAPTION : {caption}

            output will be in the format
            {json_xss}

            


        """
        pprint(xss_verification_prompt)
        response = self.llm.get_response(prompt = xss_verification_prompt)

        response = response.choices[0].message.content

        print(response)
        return response


    def verify_xss(self ,  image_path):
        

        
        caption = self.analyze_xss_image(image_path)
        response = self.check_with_llm(caption = caption)

        result = get_json_from_response(response)


        
        
        return result



        
analyzer = XSSAnalyzer()

@tool
async def check_XSS_alert( state: dict) -> str:
    """
    Checks if an alert (e.g., from an XSS payload) was triggered on the page.

    Args:
        state: A dictionary containing Playwright page context.

    Returns:
        str: "✅ XSS alert triggered!" if xss was observed,
            otherwise "❌ No XSS alert detected."
    """
    page = state["page"]
    xss_triggered = False
    screenshot_path  = "./output/xss_proof.png"
    await page.screenshot(path= screenshot_path)

    result = analyzer.verify_xss(image_path = screenshot_path)

    result = "✅ XSS alert triggered!" if (result['xss_triggered'] == True) else "❌ No XSS alert detected."
    print(result)

    state["last_action"] = result
    state["xss_detection"].append({'page':page.url , 'result':result})
    return state




if __name__ == "__main__":
    
# caption = """user 
# What text do you see in the picture ?assistant
# The image shows a screenshot of a user interface for a dashboard named "MiniCRM Dashboard." 
# The interface is designed to be user-friendly, with a clean layout and a simple color scheme.
# At the top, there are tabs labeled "Dashboard," "Contacts," "Tickets," and "Admin," suggesting that the dashboard offers various sections
# for managing different aspects of the MiniCRM system.
# Below the tabs, there is a welcome message that reads "Welcome to the MiniCRM Dashboard." The main content area of the"""
# result = get_json_from_response(check_with_llm(caption))
# result['xss_triggered']


# xss_triggered = False
# screenshot_path  = "./output/xss_proof.png"
# await page.screenshot(path= screenshot_path)

# result = verify_xss(image_path = screenshot_path)

# result = "✅ XSS alert triggered!" if (result['xss_triggered'] == True) else "❌ No XSS alert detected."
# print(result)

    pass