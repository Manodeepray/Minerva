from bs4 import BeautifulSoup


import os
import shutil
from rich.panel import Panel
import asyncio
from pyppeteer import launch
import langgraph
try:
    from .exploitation_tools import Actuators , Brain , ExploitTools
except:
    from exploitation_tools import Actuators , Brain , ExploitTools

from langchain_core.prompts import PromptTemplate
from langchain.chains import LLMChain
import json
from langchain_groq import ChatGroq
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
import os
from rich import print 
from rich.console import Group
from rich.panel import Panel
from rich.text import Text
import requests
import re

##############################variables ##########################


















def copy_executable_workflow(workflow_path , executable_workflow_dir = "./data/executable_workflows" ):
    workflow = workflow_path.split("/")[-1]    
    executable_workflow_path = os.path.join(executable_workflow_dir  , workflow )
    shutil.copy(src=workflow_path , dst= executable_workflow_path)
    return executable_workflow_path


def clean_dir(executable_workflow_dir):
    dir_ops_logs = []

    if os.path.exists(executable_workflow_dir):
        for filename in os.listdir(executable_workflow_dir):
            file_path = os.path.join(executable_workflow_dir, filename)
            try:
                if os.path.isfile(file_path) or os.path.islink(file_path):
                    os.unlink(file_path)
                    dir_ops_logs.append(f"[green]Deleted file:[/green] {file_path}")
                elif os.path.isdir(file_path):
                    shutil.rmtree(file_path)
                    dir_ops_logs.append(f"[green]Deleted folder:[/green] {file_path}")
            except Exception as e:
                dir_ops_logs.append(f"[red]Failed to delete {file_path}. Reason: {e}[/red]")
    else:
        os.makedirs(executable_workflow_dir)
        dir_ops_logs.append(f"[cyan]Created directory:[/cyan] {executable_workflow_dir}")

    dir_panel = Panel("\n".join(dir_ops_logs) or "[yellow]No existing files to delete[/yellow]",
                      title="üóÇÔ∏è Directory Cleanup", border_style="magenta")



def get_executable_workflows(failed , executable_workflow_dir = "./data/executable_workflows"):

    clean_dir(executable_workflow_dir)
    executable_workflows = []

    for k , _ in failed.items():
        if len(failed[k]["failed_steps"]) == 0:
            
            k = copy_executable_workflow(k)
            
            executable_workflows.append(k)



    return executable_workflows








def get_json_from_output(text):
    match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)

    if match:
        json_str = match.group(1)
        json_data = json.loads(json_str)
        print(json_data)
    else:
        print("No JSON found.")
    
    return json_data



async def run_plan(state ,
                   failed ,
                   agent ,
                   parsed_plan,
                   initial_page_html ,
                   page ,
                   tool_registry):
    
    
    
    
    # state = {
    #     "home_url":"http://127.0.0.1:5000/",
    #     "page":page,
    #     "page_html": initial_page_html,
    #     "current_step": 0,
    #     "history": [],
    #     "xss_detection":[]
    # }
    state["page"] = page
    state["page_html"]= initial_page_html
    
    requests.post("http://localhost:8000/update_status", json={"step": "Steps", "detail": f"executing {len(parsed_plan)} steps pf parsed plan"})

    for idx, step_info in enumerate(parsed_plan):
        print(f"\n‚û°Ô∏è Step {idx+1}: {step_info['step']}")

        page_html = state["page_html"]
        step_description = step_info["step"]
        step_action =  step_info["action"]
        # 5. LLM agent input
        agent_input = {
            "page_html": page_html,
            "step_description": step_description,
            "step_action": step_action
            
        }

        # 6. Use LLM agent to choose tool and args
        # decision_raw = await agent.ainvoke(agent_input)
        # print(decision_raw)
        # decision = json.loads(decision_raw["text"]) 

        try:
            decision_raw = await agent.ainvoke(agent_input)
            print(f"AGENT OUTPUT : {decision_raw} \n\n")
            # assumes LLMChain returns text field
            
        except Exception as e:
            print(f"‚ùå Failed to get response from agent: {e}")
            failed.append(f"‚ùå Failed to get response from agent: {e}")
            break


        try:
            decision = get_json_from_output(decision_raw["text"]) 
            print(f" EXTRACTED JSON : {decision}")
        except Exception as e:
            print(f"‚ùå Failed to parse agent output: {e}")
            failed.append(f"‚ùå Failed to parse agent output: {e}")
        
        

        tool_name = decision.get("tool")
        tool_args = decision.get("tool_args", {})
        tool_args['state'] = state
        tool_func = tool_registry.get(tool_name)
        requests.post("http://localhost:8000/update_status", json={"step": "Steps", "detail": f"using tool {tool_name}"})


        print(f"TOOL DETAILS : TOOL_NAME -> {tool_name} | TOOL_ARGS  -> {tool_args} | REGISTRY FUNC -> {tool_func} ")

        if tool_func is None:
            print(f"‚ùå Tool '{tool_name}' not found")
            failed.append(f"‚ùå Tool '{tool_name}' not found")
            break

        result = await tool_func.ainvoke(tool_args)
        new_page_html = result.get("new_page_html", page_html)
            
        
        
        
        try:
            print(f"üîß Running tool: {tool_name}")
            
            result = await tool_func.ainvoke(tool_args)
            new_page_html = result.get("new_page_html", page_html)

        except Exception as e:
            print(f"‚ùå Error running tool: {e}")
            failed.append(f"‚ùå Error running tool: {e}")
            break

        # 7. Update state
        state["history"].append({
            "step": step_info["step"],
            "tool": tool_name,
            "args": tool_args,
            "result": result
        })
        state["page_html"] = new_page_html
        state["current_step"] += 1

    print("‚úÖ All steps executed.")
    return state , failed




async def Execute(state,
                  visited_urls,
                  failed,
                  ExploitPlannerAgent,
                  ExploitExecutorAgent,
                  ExploitExecutorLLM,
                  workflow_path,
                  home_url):
    
    print(Panel(Text("üìÑ Getting exploit workflow dictionary", style="bold green"), title="Step 1: Workflow Dictionary", border_style="green"))
    requests.post("http://localhost:8000/update_status", json={"step": "Workflow Dictionary", "detail": f"Retrieving exploit workflow dictionary from path: {workflow_path}"})

    try:
        wf = ExploitPlannerAgent.get_exploit_workflow_dict(workflow_path=workflow_path,
                                                        visited_urls=visited_urls)
        requests.post("http://localhost:8000/update_status", json={"step": "Workflow Dictionary", "detail": "Successfully loaded exploit workflow dictionary"})
    except Exception as e:
        failed.append(f"‚ùå Error getting exploit workflow: {e}")
        requests.post("http://localhost:8000/update_status", json={"step": "Workflow Dictionary", "detail": f"Failed to load workflow dictionary: {e}"})
        return state, failed

    print(Panel(Text("üöÄ Launching Headless Browser", style="bold green"), title="Step 2: Browser Launch", border_style="green"))
    requests.post("http://localhost:8000/update_status", json={"step": "Browser Launch", "detail": "Initializing headless browser with security flags"})

    browser = await launch(headless=True, args=['--no-sandbox', '--disable-setuid-sandbox'])
    requests.post("http://localhost:8000/update_status", json={"step": "Browser Launch", "detail": "Headless browser launched successfully"})

    print(Panel(Text("üåê Opening Home URL and Updating State", style="bold green"), title="Step 3: Page Initialization", border_style="green"))
    requests.post("http://localhost:8000/update_status", json={"step": "Page Initialization", "detail": f"Creating new page and navigating to: {home_url}"})

    page = await browser.newPage()
    await page.goto(home_url, {'waitUntil': 'networkidle2'})
    state['page'] = page
    state["home_url"] = home_url
    state["curr_url"] = page.url
    requests.post("http://localhost:8000/update_status", json={"step": "Page Initialization", "detail": f"Page loaded successfully. Current URL: {page.url}"})

    print(Panel(Text("üõ†Ô∏è Initializing tools for interaction", style="bold magenta"), title="Step 4: Tool Setup", border_style="magenta"))
    requests.post("http://localhost:8000/update_status", json={"step": "Tool Setup", "detail": "Initializing interaction tools (navigate, click, XSS injection, alert check)"})

    tools = [
        Actuators.navigate_to_link,
        Actuators.click_button_by_html,
        ExploitTools.XSS_injection_tool,
        ExploitTools.check_XSS_alert
    ]
    state['tools'] = tools
    requests.post("http://localhost:8000/update_status", json={"step": "Tool Setup", "detail": f"Loaded {len(tools)} interaction tools into state"})

    print(Panel(Text("üì¶ Setting up tool registry", style="bold magenta"), title="Step 5: Tool Registry", border_style="magenta"))
    requests.post("http://localhost:8000/update_status", json={"step": "Tool Registry", "detail": "Creating tool registry mapping for execution"})

    tool_registry = {
        "navigate_to_link": Actuators.navigate_to_link,
        "XSS_injection_tool": ExploitTools.XSS_injection_tool,
        "click_button_by_html": Actuators.click_button_by_html,
        "check_XSS_alert": ExploitTools.check_XSS_alert,
    }
    requests.post("http://localhost:8000/update_status", json={"step": "Tool Registry", "detail": f"Tool registry created with {len(tool_registry)} tools"})

    print(Panel(Text("üìÑ Extracting initial HTML from page", style="bold yellow"), title="Step 6: Capture Initial HTML", border_style="yellow"))
    requests.post("http://localhost:8000/update_status", json={"step": "Capture Initial HTML", "detail": "Extracting page HTML content for analysis"})

    initial_page_html = await page.content()
    requests.post("http://localhost:8000/update_status", json={"step": "Capture Initial HTML", "detail": f"Captured {len(initial_page_html)} characters of HTML content"})

    print(Panel(Text("üß† Creating tool workflow from extracted plan", style="bold yellow"), title="Step 7.1: Tool Workflow Creation", border_style="yellow"))
    requests.post("http://localhost:8000/update_status", json={"step": "Tool Workflow Creation", "detail": "Converting workflow dictionary to executable tool flow"})

    tool_flow_list = ExploitPlannerAgent.create_tools_workflow(wf=wf, state=state)
    requests.post("http://localhost:8000/update_status", json={"step": "Tool Workflow Creation", "detail": f"Created tool workflow with {len(tool_flow_list)} steps"})

    print(Panel(Text("üìë Parsing tool workflow into structured execution plan", style="bold yellow"), title="Step 7.2: Plan Parsing", border_style="yellow"))
    requests.post("http://localhost:8000/update_status", json={"step": "Plan Parsing", "detail": "Parsing tool workflow into structured execution plan"})

    parsed_plan = Brain.get_parsed_plan(tool_flow_list=tool_flow_list)
    requests.post("http://localhost:8000/update_status", json={"step": "Plan Parsing", "detail": "Successfully parsed workflow into execution plan"})

    print(parsed_plan)
    print(Panel(Text("üîç Loading LLM for execution", style="bold yellow"), title="Step 7.3: Load LLM", border_style="yellow"))
    requests.post("http://localhost:8000/update_status", json={"step": "Load LLM", "detail": "Initializing LLM for exploit execution"})

    llm = ExploitExecutorLLM
    requests.post("http://localhost:8000/update_status", json={"step": "Load LLM", "detail": "LLM loaded successfully for execution"})

    print(Panel(Text("‚úçÔ∏è Retrieving prompt template", style="bold yellow"), title="Step 7.4: Load Prompt", border_style="yellow"))
    requests.post("http://localhost:8000/update_status", json={"step": "Load Prompt", "detail": "Retrieving agent prompt template"})

    prompt = ExploitExecutorAgent.get_agent_prompt()
    requests.post("http://localhost:8000/update_status", json={"step": "Load Prompt", "detail": "Agent prompt template loaded successfully"})

    print(Panel(Text("ü§ñ Creating agent chain with LLM & prompt", style="bold yellow"), title="Step 7.5: Build Executor Agent", border_style="yellow"))
    requests.post("http://localhost:8000/update_status", json={"step": "Build Executor Agent", "detail": "Creating LLM chain with executor agent prompt"})

    agent = LLMChain(llm=llm, prompt=prompt)
    requests.post("http://localhost:8000/update_status", json={"step": "Build Executor Agent", "detail": "Executor agent chain created successfully"})

    print(Panel(Text("‚öôÔ∏è Running execution plan", style="bold blue"), title="Step 8: Run Plan", border_style="blue"))
    requests.post("http://localhost:8000/update_status", json={"step": "Run Plan", "detail": "Starting execution of parsed plan with agent"})

    state, failed = await run_plan(state,
                                    failed,
                                    agent,
                                    parsed_plan,
                                    initial_page_html,
                                    page,
                                    tool_registry)
    requests.post("http://localhost:8000/update_status", json={"step": "Run Plan", "detail": f"Plan execution completed. Failures encountered: {len(failed)}"})

    print(Panel(Text("‚úÖ Execution completed successfully", style="bold green"), title="Step 9: Done", border_style="green"))
    requests.post("http://localhost:8000/update_status", json={"step": "Execution Complete", "detail": "Exploit workflow execution finished successfully"})

    summary_steps = Group(
        Text("1. üìÇ Retrieved exploit workflow dictionary", style="bold green"),
        Text("2. üöÄ Launched headless browser", style="bold cyan"),
        Text("3. üåê Navigated to home URL & set state", style="bold magenta"),
        Text("4. üõ†Ô∏è Initialized tools for interaction", style="bold yellow"),
        Text("5. üóÇÔ∏è Built tool registry", style="bold blue"),
        Text("6. üìÑ Captured initial page HTML", style="bold green"),
        Text("7. üß† Created & parsed tool flow plan", style="bold cyan"),
        Text("8. ‚öôÔ∏è Loaded agent and executed tool plan", style="bold magenta"),
        Text("9. ‚úÖ Execution completed", style="bold white"),
    )

    print(Panel(summary_steps, title="‚úÖ Execution Summary", border_style="bold white"))
    print(failed)
    return state, failed







###########$$$$$$$$$$$$$$$$$$$$$$$$$$######## main ###################################################################


from rich import print
from rich.panel import Panel


async def workflow_execution(state,
                             home_url,
                             visited_urls,
                             failed,
                             workflow_path="data/extracted_task_workflows/Workflow_3.md"):

    print(Panel.fit("üöÄ [bold cyan]Starting Workflow Execution[/bold cyan]"))

    try:
        ExploitPlannerAgent = Brain.WorkflowExtractor()
        ExploitExecutorAgent = Brain.ExecuterAgent()
        ExploitExecutorLLM = ExploitExecutorAgent.get_agent()
        print(Panel.fit("üß† [bold magenta]Agents Initialized Successfully[/bold magenta]"))
    except Exception as e:
        failed.append(f"‚ùå Error initializing agents: {e}")
        print(Panel.fit(f"[bold red]‚ùå Failed to initialize agents:[/bold red] {e}"))
        return state, failed

    try:
        state, failed = await Execute(state=state,
                                      failed=failed,
                                      home_url=home_url,
                                      visited_urls=visited_urls,
                                      workflow_path=workflow_path,
                                      ExploitPlannerAgent=ExploitPlannerAgent,
                                      ExploitExecutorAgent=ExploitExecutorAgent,
                                      ExploitExecutorLLM=ExploitExecutorLLM)
        print(Panel.fit("‚úÖ [bold green]Execution Completed[/bold green]"))
    except Exception as e:
        failed.append(f"‚ùå Error in Execute: {e}")
        print(Panel.fit(f"[bold red]‚ùå Execute Failed:[/bold red] {e}"))

    return state, failed


def main(state,
         visited_urls,
         failed,
         workflow_path,
         home_url):

    print(Panel.fit("‚öôÔ∏è [bold blue]Main Execution Started[/bold blue]"))

    state, failed = asyncio.run(workflow_execution(state=state,
                                                   home_url=home_url,
                                                   visited_urls=visited_urls,
                                                   failed=failed,
                                                   workflow_path=workflow_path))

    try:
        print(Panel.fit(f"üõ°Ô∏è [bold yellow]XSS Detection Result:[/bold yellow] {state['xss_detection']}"))
    except Exception as e:
        failed.append(f"‚ùå Error accessing XSS detection result: {e}")
        print(Panel.fit(f"[bold red]‚ùå Failed to access XSS result:[/bold red] {e}"))

    return state, failed



def batch_execution(url ="http://127.0.0.1:5000/", 
                    failed = {"./data/extracted_task_workflows/Workflow_1.md":{'failed_steps':[1]},"./data/extracted_task_workflows/Workflow_2.md":{'failed_steps':[]}},
                    visited_urls = ['http://127.0.0.1:5000/admin/settings', 'http://127.0.0.1:5000/contacts', 'http://127.0.0.1:5000/contacts/add', 'http://127.0.0.1:5000/dashboard', 'http://127.0.0.1:5000/tickets',
'http://127.0.0.1:5000/tickets/add'] ):
    states = []


    
    workflow_paths = get_executable_workflows(failed)
    requests.post("http://localhost:8000/update_status", json={"step": "Workflow Discovery", "detail": f"Found {len(workflow_paths)} executable workflows to process"})

    failed_dict = {}
    requests.post("http://localhost:8000/update_status", json={"step": "Initialization", "detail": "Initialized failed_dict for tracking workflow failures"})

    for workflow_path in workflow_paths:
        requests.post("http://localhost:8000/update_status", json={"step": "Processing Workflow", "detail": f"Starting execution of workflow: {workflow_path}"})
        
        failed = []
        state = {
            "page" : None,  # Puppeteer page instance
            "home_url": None,
            "curr_url": None,
            "last_action": None,
            "page_html": None,
            "current_step": 0,
            "history": [],
            "xss_detection" :[]
            }
        requests.post("http://localhost:8000/update_status", json={"step": "State Initialization", "detail": f"Initialized state object for workflow: {workflow_path}"})
        
        state, failed = main(state=state,
                            workflow_path=workflow_path,
                            home_url=url,
                            failed=failed,
                            visited_urls=visited_urls)
        requests.post("http://localhost:8000/update_status", json={"step": "Workflow Execution", "detail": f"Completed main execution for {workflow_path}. Failures: {len(failed)}"})
        
        states.append(state)
        requests.post("http://localhost:8000/update_status", json={"step": "State Storage", "detail": f"Stored state for workflow: {workflow_path}"})
        
        failed_dict[workflow_path] = failed
        requests.post("http://localhost:8000/update_status", json={"step": "Failure Tracking", "detail": f"Recorded {len(failed)} failures for workflow: {workflow_path}"})

    requests.post("http://localhost:8000/update_status", json={"step": "Workflow Processing Complete", "detail": f"Processed all {len(workflow_paths)} workflows. Total states: {len(states)}"})

    return states, failed_dict

if __name__ == "__main__":
    
    
    batch_execution()
